<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LCA Cards — Place first, reveal later</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --dash:#cbd5e1;

      /* Purple theme */
      --accent:#6d28d9;       /* purple */
      --accent2:#5b21b6;      /* darker purple */
      --accentSoft:#ede9fe;   /* light purple */
    }
    body{font-family:system-ui,Arial;margin:0;background:var(--bg);color:var(--text)}
    header{background:linear-gradient(90deg,var(--accent2),var(--accent));color:#fff;padding:14px 18px}
    main{max-width:1120px;margin:0 auto;padding:16px 18px}
    .grid{display:grid;grid-template-columns:1fr 1.25fr;gap:14px}
    .card{background:var(--card);border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    .muted{color:var(--muted);font-size:13px}
    .big{font-size:18px;margin:8px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center}
    .pill{background:var(--accentSoft);color:var(--accent2);border-radius:999px;padding:4px 10px;font-size:12px}
    .topbar{display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between}
    .linkbox{display:flex; gap:8px; flex-wrap:wrap; align-items:center}

    button{
      border:0;border-radius:10px;padding:10px 12px;cursor:pointer;
      background:var(--accent);color:#fff;font-weight:600
    }
    button.secondary{background:#e5e7eb;color:#111827}
    button.warn{background:#ef4444}
    button:disabled{opacity:.5;cursor:not-allowed}

    input, textarea{
      width:100%; box-sizing:border-box; padding:10px 10px; border-radius:10px;
      border:1px solid var(--border); font-family:inherit; font-size:14px;
    }
    textarea{min-height:58px; resize:vertical}

    .timeline{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;margin-top:10px}
    .slot{min-height:94px;border:2px dashed var(--dash);border-radius:12px;padding:8px;background:#fbfdff}
    .slot:hover{border-color:var(--accent)}
    .slotHeader{display:flex;justify-content:space-between;gap:8px;align-items:center}
    .slotLabel{color:var(--muted);font-size:12px}
    .placed{
      border:1px solid var(--border);border-radius:10px;padding:8px;background:#fff;margin-top:8px
    }
    .placedTitle{font-weight:700}
    .placedMeta{color:var(--muted);font-size:12px;margin-top:2px}
    .placedActions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .miniBtn{
      background:#eef2ff;color:#3730a3;border:0;border-radius:999px;
      padding:6px 10px;font-size:12px;cursor:pointer;font-weight:600
    }
    .miniBtn.remove{background:#fee2e2;color:#991b1b}
    .activeRing{outline:3px solid rgba(109,40,217,.35); outline-offset:2px}
    .ok{color:#065f46;font-weight:800}
    .bad{color:#991b1b;font-weight:800}
    code{background:#f3f4f6;padding:2px 6px;border-radius:6px}
    hr{border:none;border-top:1px solid var(--border);margin:12px 0;}
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div>
      <div style="font-weight:800;">LCA Cards — Place first, reveal later</div>
      <div class="muted" style="color:#e9d5ff">
        1) Draw → 2) Place (hidden) → 3) Reveal → 4) Reposition (optional) → 5) Next turn
      </div>
    </div>

    <div class="linkbox">
      <span class="pill" style="background:rgba(255,255,255,.18);color:#fff;">
        Room: <b id="roomLabel">—</b>
      </span>
      <button class="secondary" id="copyRoomLinkBtn" title="Copy room link">Copy room link</button>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <!-- LEFT PANEL -->
    <section class="card">
      <div class="row">
        <div class="pill">Turn: <b id="turnName">—</b></div>
        <div class="pill">Round: <b id="round">0</b></div>
        <div class="pill">Score: <b id="score">0</b></div>
        <div class="pill">Cards left: <b id="left">0</b></div>
      </div>

      <hr>

      <div style="display:grid; gap:10px;">
        <div>
          <div class="muted">Players (comma-separated)</div>
          <textarea id="playersInput" placeholder="e.g., Ana, Luis, Maria, Johan, ..."></textarea>
          <div class="muted" style="margin-top:6px;">Saved per room. Turn rotates on <b>Next turn</b>.</div>
        </div>

        <div>
          <div class="muted">Current card (data hidden until reveal)</div>
          <div class="big" id="cardName">—</div>
          <div class="row">
            <div class="pill" id="cardStage">—</div>
            <div class="pill" id="cardUnit">—</div>
          </div>
          <div class="muted" id="cardDesc" style="margin-top:8px;">Click <b>Draw</b> to start.</div>
        </div>

        <div class="row">
          <button id="drawBtn">Draw</button>
          <button id="revealBtn" disabled>Reveal</button>
          <button id="repositionBtn" class="secondary" disabled>Reposition (same turn)</button>
          <button id="nextTurnBtn" class="secondary" disabled>Next turn</button>
          <button id="resetRoomBtn" class="secondary">Reset this room</button>
        </div>

        <div>
          <div class="muted">Feedback</div>
          <div class="big" id="feedback">—</div>
          <div class="muted" id="details">—</div>
        </div>

        <div class="muted">
          Tip: Each group uses a different room link, e.g.
          <code>?room=G1</code>, <code>?room=G2</code>, <code>?room=G3</code> …
        </div>
      </div>
    </section>

    <!-- RIGHT PANEL -->
    <section class="card">
      <div style="font-weight:800;">Dateline (lower → higher impact)</div>
      <div class="muted">Place the hidden card in an empty slot, then reveal. You may reposition after revealing.</div>
      <div class="timeline" id="timeline"></div>
    </section>
  </div>
</main>

<script>
/**
 * ======= CONFIG =======
 * Google Sheets CSV "Publish to web" link.
 * Required headers:
 * Card_ID, Title, Functional_Unit, Short_Description, Impact_Value, System_Boundary
 */
const SHEET_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vT5Pe5AfNwQ8NPGoaKIODSi8aIz7vEnRToALhtfOcxnldJ4fDgXaIGYZNd6lCFYwa0lpEUkuqu9TchH/pub?gid=0&single=true&output=csv";

const SLOTS = 14;

/**
 * ======= ROOM =======
 */
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  const raw = (params.get("room") || "G1").trim();
  return raw.replace(/[^a-zA-Z0-9_-]/g, "").slice(0, 24) || "G1";
}
const ROOM = getRoomId();
document.getElementById("roomLabel").textContent = ROOM;

document.getElementById("copyRoomLinkBtn").addEventListener("click", async () => {
  const url = new URL(window.location.href);
  url.searchParams.set("room", ROOM);
  try { await navigator.clipboard.writeText(url.toString()); alert("Room link copied!"); }
  catch { prompt("Copy this link:", url.toString()); }
});

function storageKey(k){ return `LCA_GAME_${ROOM}__${k}`; }

/**
 * ======= CSV PARSER (supports quotes) =======
 */
function parseCSV(text) {
  const rows = [];
  let row = [], cur = "", inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (c === '"' && inQuotes && next === '"') { cur += '"'; i++; continue; }
    if (c === '"') { inQuotes = !inQuotes; continue; }

    if (c === "," && !inQuotes) { row.push(cur); cur = ""; continue; }
    if ((c === "\n" || c === "\r") && !inQuotes) {
      if (cur.length || row.length) { row.push(cur); rows.push(row); }
      row = []; cur = "";
      continue;
    }
    cur += c;
  }
  if (cur.length || row.length) { row.push(cur); rows.push(row); }
  return rows;
}

async function loadCardsFromSheet() {
  const res = await fetch(SHEET_CSV_URL, { cache: "no-store" });
  const text = await res.text();

  const table = parseCSV(text).filter(r => r.some(cell => (cell ?? "").trim() !== ""));
  if (table.length < 2) return [];

  const headers = table[0].map(h => h.trim());
  const idx = (name) => headers.indexOf(name);
  const get = (r, col) => (r[idx(col)] ?? "").trim();

  const cards = table.slice(1).map(r => {
    const gwp = Number(get(r, "Impact_Value"));
    return {
      id: get(r, "Card_ID"),
      name: get(r, "Title"),
      unit: get(r, "Functional_Unit"),
      desc: get(r, "Short_Description"),
      stage: get(r, "System_Boundary"),
      gwp
    };
  }).filter(c => c.id && c.name && !Number.isNaN(c.gwp));

  // Deduplicate by Card_ID
  const seen = new Set();
  return cards.filter(c => (seen.has(c.id) ? false : (seen.add(c.id), true)));
}

/**
 * ======= GAME STATE =======
 * Phases:
 * - idle: no current card
 * - drawn: current card drawn but hidden value (must place)
 * - revealed: revealed, can either reposition or next turn
 * - moving: after clicking reposition, must pick a new empty slot
 */
let CARDS = [];
let deckIds = [];
let placedBySlot = Array(SLOTS).fill(null);
let usedIds = new Set();             // cards currently on board (no duplicates)
let currentId = null;                // drawn card id
let placedSlotThisTurn = null;       // where current card is placed
let phase = "idle";
let round = 0;

let players = [];                    // parsed from input
let turnIndex = 0;

/**
 * ======= UI =======
 */
const el = (id) => document.getElementById(id);
const ui = {
  turnName: el("turnName"),
  round: el("round"),
  score: el("score"),
  left: el("left"),
  playersInput: el("playersInput"),

  cardName: el("cardName"),
  cardStage: el("cardStage"),
  cardUnit: el("cardUnit"),
  cardDesc: el("cardDesc"),

  drawBtn: el("drawBtn"),
  revealBtn: el("revealBtn"),
  repositionBtn: el("repositionBtn"),
  nextTurnBtn: el("nextTurnBtn"),
  resetRoomBtn: el("resetRoomBtn"),

  feedback: el("feedback"),
  details: el("details"),
  timeline: el("timeline"),
};

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function getCardById(id){
  return CARDS.find(c => c.id === id) || null;
}

function setFeedback(main, detail){
  ui.feedback.innerHTML = main ?? "—";
  ui.details.textContent = detail ?? "—";
}

/**
 * ======= PLAYERS + TURN =======
 */
function parsePlayers(text){
  return text
    .split(",")
    .map(s => s.trim())
    .filter(Boolean)
    .slice(0, 7); // you wanted 7 players
}

function currentPlayerName(){
  if(players.length === 0) return "—";
  return players[turnIndex % players.length];
}

function advanceTurn(){
  if(players.length > 0) turnIndex = (turnIndex + 1) % players.length;
}

/**
 * ======= SCORING (dynamic) =======
 * Score = number of cards currently consistent with nearest neighbors.
 * A card in a slot is "consistent" if:
 * left nearest has <= value and right nearest has >= value.
 */
function computeScore(){
  let count = 0;
  for(let i=0;i<SLOTS;i++){
    const id = placedBySlot[i];
    if(!id) continue;
    const c = getCardById(id);
    if(!c) continue;

    const leftIdx = [...Array(i).keys()].reverse().find(j => placedBySlot[j]);
    const rightIdx = [...Array(SLOTS-i-1).keys()].map(x=>x+i+1).find(j => placedBySlot[j]);

    let ok = true;
    if(leftIdx !== undefined){
      const lc = getCardById(placedBySlot[leftIdx]);
      if(lc && lc.gwp > c.gwp) ok = false;
    }
    if(rightIdx !== undefined){
      const rc = getCardById(placedBySlot[rightIdx]);
      if(rc && c.gwp > rc.gwp) ok = false;
    }
    if(ok) count++;
  }
  return count;
}

/**
 * ======= PERSISTENCE (per room) =======
 */
function saveRoomState(){
  const state = {
    deckIds,
    placedBySlot,
    usedIds: Array.from(usedIds),
    currentId,
    placedSlotThisTurn,
    phase,
    round,
    playersText: ui.playersInput.value || "",
    turnIndex
  };
  localStorage.setItem(storageKey("state"), JSON.stringify(state));
}

function loadRoomState(){
  const raw = localStorage.getItem(storageKey("state"));
  if(!raw) return false;

  try{
    const state = JSON.parse(raw);
    deckIds = Array.isArray(state.deckIds) ? state.deckIds : [];
    placedBySlot = Array.isArray(state.placedBySlot) ? state.placedBySlot : Array(SLOTS).fill(null);
    usedIds = new Set(Array.isArray(state.usedIds) ? state.usedIds : []);
    currentId = state.currentId ?? null;
    placedSlotThisTurn = (typeof state.placedSlotThisTurn === "number") ? state.placedSlotThisTurn : null;
    phase = state.phase || "idle";
    round = Number(state.round || 0);
    ui.playersInput.value = state.playersText || "";
    turnIndex = Number(state.turnIndex || 0);
    return true;
  } catch {
    return false;
  }
}

function resetThisRoom(){
  localStorage.removeItem(storageKey("state"));
  deckIds = [];
  placedBySlot = Array(SLOTS).fill(null);
  usedIds = new Set();
  currentId = null;
  placedSlotThisTurn = null;
  phase = "idle";
  round = 0;
  ui.playersInput.value = "";
  players = [];
  turnIndex = 0;
  setFeedback("—","—");
}

/**
 * ======= BOARD BUILD =======
 */
function buildBoard(){
  ui.timeline.innerHTML = "";
  for(let i=0;i<SLOTS;i++){
    const slotEl = document.createElement("div");
    slotEl.className = "slot";
    slotEl.dataset.slot = String(i);

    slotEl.innerHTML = `
      <div class="slotHeader">
        <span class="slotLabel">Slot ${i+1}</span>
        <span class="slotLabel" id="slotHint_${i}"></span>
      </div>
      <div class="slotBody" id="slotBody_${i}"></div>
    `;

    slotEl.addEventListener("click", () => onSlotClick(i));
    ui.timeline.appendChild(slotEl);
  }
}

/**
 * ======= RENDER =======
 */
function render(){
  // players + turn
  players = parsePlayers(ui.playersInput.value || "");
  if(players.length === 0) turnIndex = 0;
  ui.turnName.textContent = currentPlayerName();

  // stats
  ui.round.textContent = round;
  ui.score.textContent = computeScore();

  const remaining = deckIds.length + (currentId ? 1 : 0);
  ui.left.textContent = remaining;

  // current card panel
  const current = currentId ? getCardById(currentId) : null;
  if(!current){
    ui.cardName.textContent = "—";
    ui.cardStage.textContent = "—";
    ui.cardUnit.textContent = "—";
    ui.cardDesc.innerHTML = "Click <b>Draw</b> to start.";
  } else {
    ui.cardName.textContent = current.name;
    ui.cardStage.textContent = current.stage || "—";
    ui.cardUnit.textContent = current.unit || "—";

    if(phase === "drawn") ui.cardDesc.textContent = (current.desc || "") + " (value hidden)";
    if(phase === "revealed" || phase === "moving") ui.cardDesc.textContent = (current.desc || "") + " (value revealed)";
  }

  // buttons by phase
  ui.drawBtn.disabled = !(phase === "idle") || deckIds.length === 0;
  ui.revealBtn.disabled = !(phase === "drawn" && typeof placedSlotThisTurn === "number");
  ui.repositionBtn.disabled = !(phase === "revealed");      // only after reveal
  ui.nextTurnBtn.disabled = !(phase === "revealed" || phase === "moving"); // can end turn from either
  // reset always enabled

  // board
  [...ui.timeline.children].forEach((slotEl, idx) => {
    const body = slotEl.querySelector(".slotBody");
    body.innerHTML = "";
    slotEl.classList.remove("activeRing");

    const id = placedBySlot[idx];
    if(id){
      const c = getCardById(id);
      const wrap = document.createElement("div");
      wrap.className = "placed";
      wrap.innerHTML = `
        <div class="placedTitle">${c ? c.name : id}</div>
        <div class="placedMeta">${c ? `${c.stage || ""} · ${c.unit || ""}` : ""}</div>
        <div class="placedActions">
          <button class="miniBtn remove" data-remove="${id}">Remove</button>
        </div>
      `;
      body.appendChild(wrap);

      // Remove button (any time)
      wrap.querySelector(`[data-remove="${id}"]`).addEventListener("click", (e) => {
        e.stopPropagation();
        removeCardById(id);
      });

      // highlight current placed card during moving/revealed
      if(currentId && id === currentId && typeof placedSlotThisTurn === "number" && idx === placedSlotThisTurn){
        slotEl.classList.add("activeRing");
      }
    }

    // slot hint text
    const hint = slotEl.querySelector(`#slotHint_${idx}`);
    if(phase === "moving" && !placedBySlot[idx]) hint.textContent = "click to move here";
    else hint.textContent = "";
  });

  saveRoomState();
}

/**
 * ======= ACTIONS =======
 */
function ensureDeckNotEmpty(){
  // Remove any IDs that are already used (on board) to prevent duplicates
  deckIds = deckIds.filter(id => !usedIds.has(id));
}

function draw(){
  if(phase !== "idle") return;

  ensureDeckNotEmpty();
  if(deckIds.length === 0){
    setFeedback(`<span class="bad">No cards left.</span>`, "Add more cards to the sheet or reset this room.");
    render(); return;
  }

  currentId = deckIds.pop();
  if(usedIds.has(currentId)){
    // extremely defensive: skip duplicates
    currentId = null;
    draw();
    return;
  }

  phase = "drawn";
  placedSlotThisTurn = null;
  round += 1;

  setFeedback("Place the card in an empty slot (value hidden).", "Then click Reveal.");
  render();
}

function onSlotClick(slotIndex){
  // Only meaningful when we have a current card
  if(!currentId) return;

  // must be empty slot for placement/move
  if(placedBySlot[slotIndex]){
    setFeedback(`<span class="bad">Slot occupied.</span>`, "Choose an empty slot.");
    return;
  }

  if(phase === "drawn"){
    // place hidden card
    placedBySlot[slotIndex] = currentId;
    usedIds.add(currentId);
    placedSlotThisTurn = slotIndex;

    setFeedback("Ready to reveal.", `Placed in Slot ${slotIndex+1}.`);
    render();
    return;
  }

  if(phase === "moving"){
    // move the revealed current card to a new empty slot
    if(typeof placedSlotThisTurn === "number"){
      placedBySlot[placedSlotThisTurn] = null;
    }
    placedBySlot[slotIndex] = currentId;
    placedSlotThisTurn = slotIndex;

    const c = getCardById(currentId);
    setFeedback("Card moved.", `Current revealed value: ${c?.gwp ?? "—"} kgCO₂e.`);
    render();
    return;
  }

  // if revealed but not moving, clicking empty slot does nothing
}

function reveal(){
  if(!(phase === "drawn" && currentId && typeof placedSlotThisTurn === "number")) return;

  const c = getCardById(currentId);
  if(!c){
    setFeedback(`<span class="bad">Card data missing.</span>`, "Check the sheet headers and values.");
    return;
  }

  // check local consistency with neighbors right now
  const i = placedSlotThisTurn;
  const leftIdx = [...Array(i).keys()].reverse().find(j => placedBySlot[j]);
  const rightIdx = [...Array(SLOTS-i-1).keys()].map(x=>x+i+1).find(j => placedBySlot[j]);

  let ok = true;
  if(leftIdx !== undefined){
    const lc = getCardById(placedBySlot[leftIdx]);
    if(lc && lc.gwp > c.gwp) ok = false;
  }
  if(rightIdx !== undefined){
    const rc = getCardById(placedBySlot[rightIdx]);
    if(rc && c.gwp > rc.gwp) ok = false;
  }

  phase = "revealed";

  setFeedback(
    ok ? `<span class="ok">✅ Revealed</span>` : `<span class="bad">⚠ Revealed (not consistent)</span>`,
    `GWP: ${c.gwp} kgCO₂e · Boundary: ${c.stage || "—"} · You may Reposition or go Next turn.`
  );

  render();
}

function reposition(){
  if(phase !== "revealed") return;
  phase = "moving";
  setFeedback("Reposition mode.", "Click an empty slot to move the revealed card. Unlimited moves until Next turn.");
  render();
}

function nextTurn(){
  if(!(phase === "revealed" || phase === "moving")) return;

  // End turn: keep card fixed where it is. Clear current selection.
  currentId = null;
  placedSlotThisTurn = null;
  phase = "idle";
  advanceTurn();
  setFeedback("—", "—");
  render();
}

function removeCardById(id){
  // Find the slot containing this card
  const slotIndex = placedBySlot.findIndex(x => x === id);
  if(slotIndex === -1) return;

  const c = getCardById(id);

  // Remove from board & used set
  placedBySlot[slotIndex] = null;
  usedIds.delete(id);

  // If removing the current card during this turn:
  if(currentId === id){
    currentId = null;
    placedSlotThisTurn = null;
    phase = "idle";
  }

  // Return to deck (so it can appear again)
  deckIds.push(id);
  deckIds = shuffle(deckIds); // keep it mixed

  setFeedback("Card removed.", `${c ? c.name : id} was returned to the deck.`);
  render();
}

/**
 * ======= INIT =======
 */
async function init(){
  buildBoard();
  CARDS = await loadCardsFromSheet();

  // load room state if any
  const hasState = loadRoomState();

  // if no state, start fresh
  if(!hasState){
    deckIds = shuffle(CARDS.map(c => c.id));
    placedBySlot = Array(SLOTS).fill(null);
    usedIds = new Set();
    currentId = null;
    placedSlotThisTurn = null;
    phase = "idle";
    round = 0;
    turnIndex = 0;
    setFeedback("—","—");
  } else {
    // if sheet changed, clean invalid ids safely
    const valid = new Set(CARDS.map(c => c.id));
    deckIds = deckIds.filter(id => valid.has(id));
    placedBySlot = placedBySlot.map(id => (id && valid.has(id)) ? id : null);
    usedIds = new Set([...usedIds].filter(id => valid.has(id)));
    if(currentId && !valid.has(currentId)){
      currentId = null;
      placedSlotThisTurn = null;
      phase = "idle";
    }
  }

  // ensure no duplicates after load
  ensureDeckNotEmpty();

  // events
  ui.playersInput.addEventListener("input", () => {
    // keep turnIndex within bounds
    const newPlayers = parsePlayers(ui.playersInput.value || "");
    if(newPlayers.length === 0) turnIndex = 0;
    else turnIndex = Math.min(turnIndex, newPlayers.length - 1);
    render();
  });

  ui.drawBtn.addEventListener("click", draw);
  ui.revealBtn.addEventListener("click", reveal);
  ui.repositionBtn.addEventListener("click", reposition);
  ui.nextTurnBtn.addEventListener("click", nextTurn);
  ui.resetRoomBtn.addEventListener("click", () => { resetThisRoom(); init(); });

  render();
}

init();
</script>
</body>
</html>
